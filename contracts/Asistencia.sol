// SPDX-License-Identifier: MIT       Licencia del contrato - MIT una de las mas abiertas y usadas
pragma solidity ^0.8.20;  // Compilador de Solidity

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; // Importa la definición del contrato ERC20 desde la librería OpenZeppelin. Voy a poder crear un token (como si fuera una moneda digital) sin tener que programarlo desde cero. Puedo Crear tokens, Transferirlos, Consultar saldos,etc.
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol"; // Importa la definición del contrato AccessControl desde la librería OpenZeppelin que permite manejar roles y permisos. Permite que el "profesor" pueda hacer algunas cosas y los "alumnos" otras.
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // Importa la definición del contrato ReentrancyGuard desde la librería OpenZeppelin que permite evitar el reentrancy. que es como si alguien intentara "aprovechar un error" y ejecutar varias veces una función antes de que termine la anterior. Con ReentrancyGuard, te asegurás de que las funciones importantes se ejecuten una sola vez por turno, como deberían.

contract Asistencia is ERC20, AccessControl, ReentrancyGuard { //con el is se heredan las caracteristicas de los contratos ERC20, AccessControl y ReentrancyGuard

    bytes32 public constant PROFE_ROLE = keccak256("PROFE_ROLE"); // bytes32 Este es el tipo de dato. Significa que la variable va a guardar un valor de 32 bytes (256 bits). public Es un modificador de visibilidad. Significa que esta variable puede ser leída desde fuera del contrato (por otras funciones o por usuarios desde interfaces como Remix o Web3). constant Esto indica que el valor de esta variable es constante, es decir, no va a cambiar nunca después de ser definida. Se fija en el momento del despliegue del contrato. Ahorra gas porque no necesita guardarse en almacenamiento (solo en el bytecode). PROFE_ROLE Este es el nombre de la variable. Por convención, los nombres de constantes en Solidity se escriben en mayúsculas y con guiones bajos.  keccak256("PROFE_ROLE") Esto es una función hash que genera un valor único de 32 bytes a partir del string "PROFE_ROLE". keccak256(...) es la función de hash criptográfica estándar en Solidity (similar a SHA3). "PROFE_ROLE" es un string literal que se va a hashear. ¿Por qué se usa? En contratos de control de acceso (como con OpenZeppelin), se utiliza este hash como un identificador único para un rol. Por ejemplo, para saber si alguien tiene el rol de "PROFE".

    struct Session {  // Estructura para representar una sesión. Un struct es como un molde para crear "objetos" con varias propiedades
        bytes32 hash; // bytes32 Este es el tipo de dato. Significa que la variable va a guardar un valor de 32 bytes (256 bits).
        uint256 deadline; // unit256 Este es el tipo de dato. Significa que la variable va a guardar un valor de 256 bits. deadline La fecha límite para reclamar tokens, probablemente como una marca de tiempo Unix (block.timestamp), después de la cual la sesión ya no es válida.
        bool activa; // bool tipo de dato que significa que la variable va a guardar un valor booleano (true o false).Indica si la sesión está activa o no.
    }

    mapping(uint256 => Session) public sesiones; // mapping(address => bool) public alumnosPermitidosEste es un diccionario que relaciona un número (el ID de la sesión) con una estructura Session. Sirve para guardar todas las sesiones, y se puede acceder a cada una usando su ID (por ejemplo, 1, 2, 3...). Ejemplo: sesiones[1] te devuelve los datos de la sesión con ID 1. Como es public, se puede consultar directamente desde fuera del contrato.;
    mapping(address => bool) public alumnosPermitidos; //  Un mapping en Solidity es como un diccionario o una tabla de búsqueda. Sirve para asociar una clave con un valor. En este caso, se está creando una estructura que relaciona una dirección (address) con un valor booleano (bool). (address => bool) address: es la clave. Representa una dirección de Ethereum (como la de un usuario o un contrato). =>: indica que se va a mapear (asociar) una clave con un valor. bool: es el valor. Representa un valor booleano (verdadero o falso, o en código: true o false). Esto hace que la variable alumnosPermitidos sea pública, lo que significa que cualquiera puede consultar su contenido desde fuera del contrato. Solidity genera automáticamente una función de lectura para mappings públicos
    uint256 private sessionCounter; // Relaciona una dirección Ethereum (wallet) con un booleano. Indica si una dirección está permitida o no para participar en las sesiones (por ejemplo, si es un alumno autorizado). Ejemplo: alumnosPermitidos[0xABC...] == true significa que esa dirección está habilitada.
    mapping(uint256 => mapping(address => bool)) public haReclamado; // La declaración mapping(uint256 => mapping(address => bool)) public haReclamado; define un mapping en Solidity que tiene una estructura de diccionario anidado. En primer lugar, el primer mapping mapea un valor de tipo uint256 (números enteros sin signo, como identificadores o índices) a otro mapping. Este segundo mapping mapea una dirección (address) a un valor booleano (bool). Esto indica que para cada valor de tipo uint256, se tiene un sub-diccionario donde las claves son direcciones (address) y los valores son booleanos que indican si una determinada dirección ha realizado alguna acción, como reclamar un beneficio o acceder a una función. Al ser público, Solidity genera automáticamente una función de lectura que permite consultar si una dirección en particular ya ha reclamado algo para un identificador específico (por ejemplo, verificar si un usuario ha reclamado un premio para una campaña).

    event AlumnoRegistrado(address indexed alumno); //  declara un evento en Solidity llamado AlumnoRegistrado, que se utiliza para registrar la dirección de un alumno cuando ocurre algún evento relacionado con el registro en el contrato. El parámetro alumno es de tipo address y está marcado con la palabra clave indexed, lo que significa que se indexa y facilita su búsqueda en los registros de eventos de la blockchain. Los eventos en Solidity permiten que las aplicaciones externas (como interfaces de usuario o dApps) escuchen y reaccionen a estos cambios, como por ejemplo, mostrar una notificación cuando un alumno se registra exitosamente.
    event SessionCreada(uint256 indexed sessionId, bytes32 hash, uint256 deadline); //La línea event SessionCreada(uint256 indexed sessionId, bytes32 hash, uint256 deadline); declara un evento en Solidity llamado SessionCreada, utilizado para registrar la creación de una nueva sesión dentro del contrato. El primer parámetro, sessionId, es de tipo uint256 y está marcado como indexed, lo que permite buscar este valor fácilmente en los registros de eventos de la blockchain. El segundo parámetro, hash, es de tipo bytes32 y sirve para almacenar un valor hash relacionado con la sesión, como una firma o un identificador encriptado que represente datos específicos de la sesión. El tercer parámetro, deadline, también es de tipo uint256 y representa la fecha o el tiempo límite hasta el cual la sesión estará activa o válida. Este evento permite a aplicaciones externas como interfaces web o dApps detectar automáticamente cuándo se crea una nueva sesión, para actualizar la información visible para los usuarios o gestionar acciones relacionadas con esa sesión.
    event TokenReclamado(address indexed estudiante, uint256 cantidad, uint256 sessionId); // La línea event TokenReclamado(address indexed estudiante, uint256 cantidad, uint256 sessionId); declara un evento en Solidity llamado TokenReclamado, que se utiliza para registrar cuando un estudiante reclama tokens dentro del contrato. El primer parámetro, estudiante, es de tipo address y está marcado como indexed, lo que permite buscar rápidamente en los registros quién reclamó tokens. El segundo parámetro, cantidad, es de tipo uint256 y representa la cantidad de tokens que el estudiante ha reclamado. El tercer parámetro, sessionId, también es de tipo uint256 y se refiere al identificador de la sesión en la cual se realizó el reclamo. Este evento facilita que aplicaciones externas, como dApps o interfaces web, puedan detectar cuándo un estudiante ha reclamado sus tokens y con qué cantidad, permitiendo actualizar balances, mostrar notificaciones o llevar un seguimiento de las sesiones.

    constructor(   // La línea constructor( es el inicio de la declaración de un constructor en Solidity. Un constructor es una función especial que se ejecuta una sola vez, automáticamente, en el momento en que se despliega (o "instala") el contrato en la blockchain. Su propósito principal es inicializar el estado del contrato, es decir, configurar variables, establecer roles como el dueño del contrato, o ejecutar cualquier lógica que solo debe ocurrir al inicio. A diferencia de otras funciones, el constructor no tiene nombre y no puede ser llamado después de que el contrato ha sido desplegado. Todo lo que se coloque dentro del cuerpo del constructor ({ ... }) será ejecutado inmediatamente en el momento de la creación del contrato.
        string memory nombre, //  La línea string memory nombre, es parte de la lista de parámetros que puede recibir una función o constructor en Solidity. En este caso, se está declarando un parámetro llamado nombre de tipo string, que representa una cadena de texto. La palabra clave memory indica que esta variable vivirá temporalmente en memoria mientras se ejecuta la función o constructor, y no se almacenará de forma permanente en la blockchain.
        string memory simbolo, // La línea string memory simbolo, es otro parámetro que puede formar parte de la definición de una función o constructor en Solidity. Aquí se está declarando una variable llamada simbolo de tipo string, que almacena una cadena de texto, usualmente corta, como una abreviatura o código identificador. La palabra clave memory indica que este valor se almacenará temporalmente durante la ejecución de la función, sin guardarse de forma permanente en la blockchain. Este tipo de parámetro es común en contratos relacionados con tokens, donde el simbolo puede representar, por ejemplo, una abreviación como "ETH", "DAI" o "ABC", y se utiliza para identificar de forma breve un token o entidad dentro del contrato.
        address professor //  La línea address professor declara un parámetro llamado professor de tipo address, que representa una dirección de Ethereum. Este parámetro generalmente se utiliza para identificar a una cuenta específica, en este caso, la de un profesor, que probablemente tendrá un rol especial dentro del contrato. A diferencia de los parámetros tipo string, los address no necesitan una ubicación de almacenamiento como memory o storage, ya que son tipos de valor simples. Este parámetro puede usarse, por ejemplo, para asignar permisos especiales al profesor, registrarlo como el creador de una sesión o curso, o autorizarlo para ejecutar ciertas funciones del contrato.
    ) ERC20(nombre, simbolo){ // La línea ERC20(nombre, simbolo){ corresponde al inicio del constructor de un contrato en Solidity que hereda de otro contrato, específicamente del estándar ERC20. Al escribir ERC20(nombre, simbolo), se está llamando al constructor del contrato padre (en este caso, el contrato ERC20) y pasándole los parámetros nombre y simbolo, que probablemente fueron recibidos como parámetros en el constructor del contrato actual.
        require(professor != address(0)); // La línea require(professor != address(0)); es una instrucción de validación en Solidity que se utiliza para asegurarse de que la dirección professor no sea la dirección nula, también conocida como address(0). Esta dirección especial (0x0000000000000000000000000000000000000000) representa una dirección vacía o no válida en Ethereum. La función require(...) verifica una condición, y si no se cumple, la ejecución del contrato se detiene y se revierte cualquier cambio realizado hasta ese punto.
        _grantRole(PROFE_ROLE, professor); // _grantRole es una función interna que otorga un rol determinado a una cuenta (dirección). PROFE_ROLE representa un identificador único (generalmente un bytes32) para un rol específico, en este caso, uno que probablemente está destinado a los profesores. professor es la dirección a la que se le está otorgando ese rol. Esta línea asegura que la dirección proporcionada como professor tenga los permisos y privilegios asociados al rol PROFE_ROLE, permitiéndole realizar acciones específicas dentro del contrato, como crear sesiones, validar acciones o distribuir tokens, según lo definido por la lógica del contrato.

    }

    /**
     * @dev Permite al profesor registrar a un alumno.
     * @param _alumno Dirección del alumno a registrar.
     */
    function registrarAlumno(address _alumno) public onlyRole(PROFE_ROLE) { //  La línea function registrarAlumno(address _alumno) public onlyRole(PROFE_ROLE) { define una función pública llamada registrarAlumno, que permite a los usuarios con el rol de "profesor" (especificado por PROFE_ROLE) registrar a un alumno proporcionando su dirección de Ethereum. El parámetro _alumno de tipo address representa la dirección del alumno que se va a registrar. El modificador onlyRole(PROFE_ROLE) restringe el acceso a la función solo a aquellos usuarios que tienen el rol de "profesor", asegurando que solo personas autorizadas puedan registrar nuevos alumnos.
        require(_alumno != address(0), "Direccion invalida"); //  La línea require(_alumno != address(0), "Direccion invalida"); es una instrucción de validación en Solidity que asegura que el parámetro _alumno, que representa la dirección del alumno, no sea la dirección nula (es decir, address(0)). Esta dirección especial (0x0000000000000000000000000000000000000000) se utiliza para indicar una dirección inválida o no asignada. Si el parámetro _alumno es igual a address(0), la ejecución del contrato se detendrá y se revertirá la transacción, mostrando el mensaje de error "Direccion invalida". Esto previene que el contrato registre una dirección no válida, garantizando la integridad de las operaciones.
        require(!alumnosPermitidos[_alumno], "Alumno ya registrado"); // La línea require(!alumnosPermitidos[_alumno], "Alumno ya registrado"); es una instrucción de validación en Solidity que asegura que el alumno que se está intentando registrar no haya sido registrado previamente. alumnosPermitidos[_alumno]: Esta expresión consulta el mapping alumnosPermitidos para verificar si la dirección _alumno ya está marcada como true, lo que indicaría que el alumno ya ha sido registrado. !: El operador de negación ! invierte el valor booleano, por lo que si alumnosPermitidos[_alumno] es true (es decir, el alumno ya está registrado), la condición !alumnosPermitidos[_alumno] será false. "Alumno ya registrado": Si la condición no se cumple (es decir, si el alumno ya está registrado), la ejecución del contrato se detendrá y se revertirá la transacción, mostrando el mensaje de error "Alumno ya registrado".

        alumnosPermitidos[_alumno] = true; // La línea alumnosPermitidos[_alumno] = true; asigna el valor true al mapping alumnosPermitidos para la dirección _alumno, indicando que el alumno ha sido registrado correctamente. alumnosPermitidos[_alumno]: Esto hace referencia al mapping alumnosPermitidos, que asocia direcciones de Ethereum (como las de los alumnos) con valores booleanos. En este caso, la clave es la dirección del alumno (_alumno), y el valor es un booleano que indica si el alumno está permitido (registrado). = true: Al asignar true a la dirección _alumno, se marca esa dirección como registrada o permitida en el sistema. En resumen, esta línea actualiza el registro del alumno, indicándole al contrato que la dirección _alumno ha sido validada y registrada correctamente como un alumno permitido.

        emit AlumnoRegistrado(_alumno); // La línea emit AlumnoRegistrado(_alumno); emite un evento llamado AlumnoRegistrado en Solidity, lo que permite notificar a las aplicaciones externas que un alumno ha sido registrado correctamente. emit: Esta palabra clave se utiliza para disparar (o "emitir") un evento en Solidity. Cuando se emite un evento, los registros de la blockchain se actualizan con los datos asociados a ese evento, lo que permite que aplicaciones externas (como interfaces de usuario o dApps) puedan escuchar y reaccionar a estos cambios.  AlumnoRegistrado: Este es el nombre del evento que se ha definido previamente en el contrato. En este caso, el evento está diseñado para registrar la dirección del alumno que ha sido registrado. _alumno: Este es el parámetro que se pasa al evento. Es la dirección de Ethereum del alumno que se acaba de registrar. En resumen, esta línea emite el evento AlumnoRegistrado con la dirección del alumno, lo que permite que las aplicaciones externas reciban la notificación de que un alumno ha sido registrado en el sistema.
  }

    /**
     * @dev Permite al profesor crear una nueva sesión estableciendo un hash y una duración en días.
     * @param _hash El hash que representa la palabra secreta para la sesión.
     * @param _duracionEnDias Duración en días para la ventana de reclamación.
     */
    function crearSesion(bytes32 _hash, uint256 _duracionEnDias) public onlyRole(PROFE_ROLE) { //La línea function crearSesion(bytes32 _hash, uint256 _duracionEnDias) public onlyRole(PROFE_ROLE) { define una función pública llamada crearSesion, que permite a los usuarios con el rol de "profesor" (especificado por PROFE_ROLE) crear una nueva sesión proporcionando dos parámetros: _hash, que es un valor de tipo bytes32 utilizado para almacenar un hash relacionado con la sesión (como una firma o identificador único), y _duracionEnDias, que es un valor de tipo uint256 que especifica la duración de la sesión en días. El modificador onlyRole(PROFE_ROLE) restringe el acceso a esta función, asegurando que solo los usuarios con el rol de "profesor" puedan ejecutar esta acción.
        require(_duracionEnDias > 0, "Duracion debe ser mayor que cero"); // La línea require(_duracionEnDias > 0, "Duracion debe ser mayor que cero"); es una instrucción de validación en Solidity que asegura que el parámetro _duracionEnDias, que representa la duración de la sesión en días, sea un valor positivo. Si el valor de _duracionEnDias es menor o igual a 0, la ejecución del contrato se detendrá y se revertirá la transacción, mostrando el mensaje de error "Duracion debe ser mayor que cero". Esto garantiza que la duración de la sesión tenga un valor válido y razonable, evitando errores o datos incorrectos.

        uint256 deadline = block.timestamp + (_duracionEnDias * 1 days); // La línea uint256 deadline = block.timestamp + (_duracionEnDias * 1 days); calcula la fecha y hora de vencimiento (deadline) de una sesión, sumando la duración en días a la marca de tiempo actual. Utiliza block.timestamp para obtener el tiempo actual del bloque, en segundos desde la época UNIX, y luego multiplica la duración de la sesión (_duracionEnDias) por 1 days (que representa la cantidad de segundos en un día, es decir, 86,400 segundos). Al sumar este valor a block.timestamp, se obtiene la fecha y hora exacta en que la sesión expira, la cual se almacena en la variable deadline. Esto permite establecer un límite de tiempo para la sesión, asegurando que no sea válida más allá de ese momento.

        uint256 sessionId = sessionCounter + 1; // La línea uint256 sessionId = sessionCounter + 1; define una nueva variable llamada sessionId que se utiliza para asignar un identificador único a una nueva sesión. La variable sessionCounter probablemente lleva un conteo de las sesiones creadas hasta el momento. Al sumarle 1, se genera un nuevo identificador único para la siguiente sesión. Este valor se almacena en sessionId, asegurando que cada sesión tenga un ID único e incremental, lo que facilita su seguimiento y referencia en el contrato.
        sessionCounter = sessionId; // La línea sessionCounter = sessionId; actualiza la variable sessionCounter con el valor de sessionId, lo que significa que el contador de sesiones se incrementa al último ID de sesión creado. Esto garantiza que el contador siempre refleje el último identificador de sesión utilizado, asegurando que el próximo sessionId generado sea único e incremental, listo para la creación de una nueva sesión en el futuro. En resumen, esta línea actualiza el contador para que siempre esté sincronizado con el ID de la sesión más reciente.

        sesiones[sessionId] = Session({ // La línea sesiones[sessionId] = Session({ está asignando un nuevo valor al mapping sesiones, utilizando el sessionId como clave para almacenar una nueva sesión. La clave sessionId identifica de manera única a cada sesión, y el valor asignado es una nueva instancia de la estructura Session, que probablemente contiene información relevante sobre la sesión, como la duración, el hash o la fecha límite. Esta línea permite almacenar los detalles de la sesión en el mapping, asegurando que cada sesión tenga su propio conjunto de datos accesibles a través de su identificador único.
             hash: _hash, // La línea hash: _hash, está asignando el valor del parámetro _hash a la propiedad hash de la estructura Session. Esto significa que el valor de _hash (probablemente un hash relacionado con la sesión, como un identificador único o un valor firmado) se guarda en el campo hash de la nueva sesión que se está creando. Esta asignación se realiza dentro de la inicialización de la estructura Session, asegurando que el valor del hash esté asociado con la sesión correspondiente en el mapping sesiones.
             deadline: deadline, //  La línea deadline: deadline, asigna el valor de la variable deadline al campo deadline de la estructura Session. Esto significa que la fecha y hora de vencimiento, previamente calculada en el contrato, se guarda en el campo deadline de la nueva sesión. Al hacer esto, se asegura que cada sesión tenga una fecha de vencimiento asociada, que se almacena como parte de los datos de esa sesión dentro del mapping sesiones.
             activa: true // La línea activa: true, asigna el valor true al campo activa de la estructura Session. Esto indica que la sesión está marcada como activa en el momento de su creación. Al establecer este valor en true, se señala que la sesión está habilitada o en curso, lo que puede implicar que aún es válida o está disponible para ser interactuada o reclamada, dependiendo de la lógica del contrato. Esta asignación se realiza dentro de la inicialización de la estructura Session, asegurando que el estado de la sesión esté correctamente marcado al momento de su creación.
         });

        emit SessionCreada(sessionId, _hash, deadline); //  se está emitiendo un evento llamado SessionCreada, que se usa para registrar información en la blockchain, permitiendo que aplicaciones externas (como un frontend) puedan escuchar este evento y reaccionar ante él. Los tres parámetros que se pasan al evento son: sessionId, que es un identificador único para la sesión; _hash, que probablemente sea un hash relacionado con algún dato de la sesión (como una transacción o archivo); y deadline, que es un valor de tiempo o número de bloque que indica cuándo expira la sesión o el plazo. Para que esto funcione correctamente, el evento debe haberse declarado previamente en el contrato con una línea como event SessionCreada(uint256 indexed sessionId, bytes32 indexed _hash, uint256 deadline); y, cuando se llama a la función que emite el evento, se registran estos valores en la blockchain para que puedan ser consultados posteriormente.
    }

    /**
     * @dev Función para obtener detalles de una sesión específica.
     * @param _sessionId ID de la sesión a consultar.
     * @return hash El hash de la sesión.
     * @return deadline La fecha límite para reclamar tokens.
     * @return activa El estado de la sesión.
     */
     function obtenerSesion(uint256 _sessionId) public view returns (bytes32 hash, uint256 deadline, bool activa) { // La función obtenerSesion es una función pública y de solo lectura en Solidity, que recibe un identificador de sesión _sessionId como parámetro y devuelve tres valores: un hash de 32 bytes, un deadline (probablemente el momento de vencimiento de la sesión) y un valor booleano activa que indica si la sesión está activa o no. Esta función no modifica el estado de la blockchain, solo recupera y devuelve estos datos relacionados con la sesión solicitada. bytes32 hash: Un valor de tipo bytes32 que podría ser una cadena de 32 bytes, probablemente un valor de hash asociado a la sesión. uint256 deadline: Un valor de tipo uint256 que podría ser la fecha y hora límite (en formato de timestamp) para esa sesión.bool activa: Un valor de tipo bool que puede ser true o false, indicando si la sesión está activa o no.
         require(_sessionId > 0 && _sessionId <= sessionCounter, "Session ID invalido"); //  require: Es una función integrada en Solidity que se usa para hacer una verificación. Si la condición que se pasa a require es falsa, se revertirá la transacción y el contrato no realizará ninguna acción posterior. (_sessionId > 0 && _sessionId <= sessionCounter): Esta es la condición que se está verificando. Significa que el sessionId debe ser mayor que cero (_sessionId > 0) y menor o igual que el contador de sesiones (_sessionId <= sessionCounter). El && es el operador lógico "Y", lo que significa que ambas condiciones deben ser ciertas para que el require pase sin errores. _sessionId > 0: Verifica que el identificador de la sesión debe ser mayor que cero. Esto asegura que no se pueda usar un identificador negativo o cero, lo cual no tiene sentido para un identificador de sesión válido. _sessionId <= sessionCounter: Verifica que el sessionId no sea mayor que el contador total de sesiones (sessionCounter). Esto significa que el identificador de la sesión debe estar dentro del rango de sesiones creadas. "Session ID invalido": Este es el mensaje de error que se mostrará si la condición del require no se cumple. Si el sessionId proporcionado no está en el rango válido, este mensaje se enviará para que el usuario o desarrollador sepa que el identificador de sesión proporcionado no es válido.
         Session memory sesion = sesiones[_sessionId]; // Session: Es el tipo de dato que se está utilizando. En Solidity, esto podría ser una estructura (struct) previamente definida. Una estructura (struct) es una forma de agrupar datos de diferentes tipos bajo un solo nombre. En este caso, Session es el tipo de datos que define la sesión y probablemente contiene varios valores relacionados con una sesión, como el hash, deadline y activa, por ejemplo. memory: Especifica que la variable sesion se almacena en la memoria temporal del contrato, no en el almacenamiento persistente de la blockchain. Esto significa que sesion solo existe durante la ejecución de la función, y no se guarda a largo plazo en la blockchain. La palabra clave memory es importante porque, en Solidity, las variables pueden almacenarse en la memoria o en el almacenamiento (storage), y este es un caso donde queremos que la variable sea temporal. sesion: Es el nombre de la variable donde se almacenará el valor obtenido. En este caso, es una variable de tipo Session que almacena la información de la sesión. En otras palabras, esta variable representará una instancia de la estructura Session con los valores que se extraen de sesiones[_sessionId]. = sesiones[_sessionId]: Aquí es donde se está obteniendo la información de la sesión. Se asume que sesiones es un mapeo (mapping), que es una estructura de datos en Solidity que se usa para almacenar pares clave-valor. En este caso, _sessionId es la clave (un identificador único de la sesión) y el valor asociado a esa clave es una estructura Session. sesiones[_sessionId]: Esta expresión obtiene el valor almacenado en el mapeo sesiones para la clave _sessionId. Ese valor es un objeto de tipo Session, que se asigna a la variable sesion. esta línea carga la información de la sesión específica en una variable local que se puede utilizar dentro de la función.
         return (sesion.hash, sesion.deadline, sesion.activa); // La línea return (sesion.hash, sesion.deadline, sesion.activa); devuelve tres valores de la estructura sesion que fueron almacenados previamente en la variable temporal sesion (que contiene la información de la sesión). Estos tres valores son el hash, el deadline y el estado activo (activa) de la sesión. Esta línea hace que la función retorne estos valores a quien la haya llamado, permitiendo que puedan ser utilizados por otros contratos o usuarios que consulten la sesión.
     }

     /**
      * @dev Permite a un alumno registrado reclamar tokens proporcionando la palabra secreta para una sesión específica.
      * @param _sessionId ID de la sesión para la cual se reclama tokens.
      * @param _palabra La palabra secreta a ser hasheada y verificada.
      */
      function reclamarTokens(uint256 _sessionId, string memory _palabra) public nonReentrant { // function: Esta palabra clave indica que estamos declarando una función en Solidity. Una función es un bloque de código que realiza una acción específica, y esta se ejecutará cuando alguien la llame. reclamarTokens: Es el nombre de la función. El nombre se elige para reflejar lo que hace la función. En este caso, el nombre sugiere que esta función está diseñada para permitir a los usuarios "reclamar" tokens (probablemente en el contexto de un contrato que maneja tokens, como un token ERC-20 o similar). (uint256 _sessionId, string memory _palabra): Estos son los parámetros de entrada de la función, es decir, los valores que la función espera recibir cuando se invoque.uint256 _sessionId: Este es el primer parámetro de la función. Es un número entero no negativo de 256 bits (un tipo de dato muy común en Solidity), y en este caso, representa el identificador único de una sesión. El parámetro se llama _sessionId, y los usuarios deben proporcionarlo cuando llamen a la función.string memory _palabra: Este es el segundo parámetro. string es un tipo de dato que almacena texto, y memory indica que el valor de este string se almacenará en la memoria temporal del contrato (es decir, no se guardará de manera permanente en la blockchain, sino solo durante la ejecución de la función). El nombre de este parámetro es _palabra, y parece ser una palabra o frase que se utilizará en el proceso de reclamar tokens.public: Este es un modificador de acceso. Indica que la función puede ser llamada por cualquier persona o contrato, es decir, está disponible para ser utilizada tanto dentro del contrato como desde fuera de él (por otros contratos o direcciones externas).nonReentrant: Este es un modificador de seguridad que se utiliza para prevenir un tipo de ataque conocido como reentrancy attack (ataque de reentrada). Los ataques de reentrada son vulnerabilidades en contratos inteligentes que pueden ocurrir cuando un contrato llama a otro contrato y este, a su vez, hace una llamada recursiva al primer contrato, causando un bucle que puede ser explotado por un atacante. El modificador nonReentrant evita que la función sea llamada recursivamente mientras se está ejecutando, asegurando que no se pueda "reentrar" en la función de manera no deseada.
          // Checks: Verificaciones
          require(alumnosPermitidos[msg.sender], "No estas autorizado para reclamar tokens"); //  es una validación que se realiza dentro de una función en Solidity antes de continuar con la ejecución. Utiliza el require para comprobar si la dirección que llama a la función (es decir, el msg.sender) está autorizada para reclamar tokens. alumnosPermitidos es probablemente un mapeo que almacena direcciones de los usuarios autorizados, y si la dirección de quien hace la llamada (representada por msg.sender) está presente y tiene un valor asociado a true en este mapeo, la condición pasa sin problemas. Si no, el require revertirá la transacción y mostrará el mensaje de error "No estas autorizado para reclamar tokens". Esto asegura que solo los usuarios previamente autorizados, es decir, aquellos registrados en el mapeo alumnosPermitidos, puedan realizar la acción de reclamar tokens, evitando que usuarios no autorizados accedan a esa funcionalidad.
          require(_sessionId > 0 && _sessionId <= sessionCounter, "Session ID invalido"); // realiza una validación para asegurar que el identificador de sesión (_sessionId) proporcionado sea válido antes de proceder con la ejecución de la función en Solidity. Utiliza el comando require, que verifica si se cumple la condición especificada; si no es así, revierte la transacción y devuelve un mensaje de error. En este caso, la condición verifica dos cosas: primero, que el _sessionId sea mayor que cero (_sessionId > 0), garantizando que el identificador no sea negativo ni cero; segundo, que el _sessionId esté dentro del rango válido de sesiones, es decir, que no sea mayor que sessionCounter, que probablemente es un contador de sesiones creadas hasta el momento. Si cualquiera de estas condiciones no se cumple, la función no continuará y el mensaje "Session ID invalido" será mostrado como error, indicando que el identificador de sesión proporcionado no es válido.
          Session memory sesion = sesiones[_sessionId];  // La línea de código Session memory sesion = sesiones[_sessionId]; recupera la información de una sesión almacenada en un contrato inteligente y la almacena en una variable temporal. Aquí, Session es probablemente una estructura (struct) previamente definida que contiene datos relacionados con una sesión (como un hash, un deadline, etc.). El modificador memory indica que la variable sesion se almacenará en la memoria temporal del contrato, lo que significa que solo existirá durante la ejecución de la función, y no será almacenada permanentemente en la blockchain.  sesiones[_sessionId] es un acceso al mapeo sesiones, que es una estructura de datos clave-valor. El _sessionId es la clave que se pasa como argumento, y el valor correspondiente es una instancia de la estructura Session asociada a ese identificador. Esta línea toma el valor de esa sesión y lo asigna a la variable sesion. En resumen, la línea Session memory sesion = sesiones[_sessionId]; carga los datos de la sesión identificada por _sessionId en una variable temporal sesion para su posterior uso dentro de la función.

          require(sesion.activa, "La sesion no esta activa"); // La línea de código require(sesion.activa, "La sesion no esta activa"); realiza una verificación sobre el estado de la sesión antes de continuar con la ejecución de la función. Utiliza el require para comprobar si la condición es verdadera. En este caso, sesion.activa es una propiedad de la estructura sesion, que probablemente es un valor booleano (bool) que indica si la sesión está activa o no. Si sesion.activa es true, la ejecución de la función continuará sin problemas. Sin embargo, si sesion.activa es false, la condición fallará y la transacción será revertida, mostrando el mensaje de error "La sesion no esta activa". Esto asegura que solo se puedan realizar acciones (como reclamar tokens, por ejemplo) si la sesión correspondiente está activa. Si no lo está, se evita que el proceso continúe, protegiendo la lógica del contrato.
          require(block.timestamp <= sesion.deadline, "La ventana de reclamacion ha cerrado"); // La línea de código require(block.timestamp <= sesion.deadline, "La ventana de reclamacion ha cerrado"); verifica si la acción que se está intentando realizar está dentro del tiempo permitido de la sesión. Utiliza block.timestamp, que representa el tiempo actual de la blockchain, y lo compara con sesion.deadline, que es el momento límite hasta el cual se puede realizar la acción. Si el tiempo actual es menor o igual al deadline de la sesión, la ejecución de la función continúa normalmente. Sin embargo, si el tiempo actual ha superado el deadline, la condición falla y la transacción se revierte, mostrando el mensaje de error "La ventana de reclamacion ha cerrado". Esto garantiza que las acciones solo se puedan realizar dentro del período de tiempo autorizado, evitando reclamaciones fuera de la ventana válida.
          require(!haReclamado[_sessionId][msg.sender], "Ya has reclamado tokens para esta sesion"); //La línea de código require(!haReclamado[_sessionId][msg.sender], "Ya has reclamado tokens para esta sesion"); garantiza que un usuario no pueda reclamar tokens más de una vez para la misma sesión. Utiliza un mapeo haReclamado[_sessionId][msg.sender] para verificar si el usuario, identificado por msg.sender, ya ha reclamado tokens en la sesión específica _sessionId. Si el valor es true, lo que indica que ya se ha realizado la reclamación, la transacción se revierte y se muestra el mensaje de error "Ya has reclamado tokens para esta sesion". Si el valor es false, la función continúa, permitiendo que el usuario reclame tokens por primera vez. Esto previene reclamaciones duplicadas y asegura una distribución justa de tokens.



          bytes32 hashCalculado = keccak256(abi.encodePacked(_palabra)); // La expresión bytes32 hashCalculado = keccak256(abi.encodePacked(_palabra)) se utiliza para calcular un hash criptográfico de 32 bytes (256 bits) a partir de la entrada proporcionada, que en este caso es la variable _palabra. Primero, la función abi.encodePacked toma el valor de _palabra y lo codifica en un formato binario adecuado para la EVM. Luego, keccak256 toma este valor codificado y genera un hash único de 256 bits. Finalmente, el resultado se asigna a la variable hashCalculado, que almacenará el valor del hash resultante. Este proceso es útil para garantizar la integridad y la unicidad de los datos en aplicaciones basadas en la blockchain.

          require(hashCalculado == sesion.hash, "Palabra secreta incorrecta"); // La palabra clave require es una función de Solidity que detiene la ejecución del contrato y revierte cualquier cambio en la blockchain si la condición proporcionada es falsa. En este caso, la condición está comparando dos valores. La condición hashCalculado == sesion.hash verifica si el valor de la variable hashCalculado es igual al valor almacenado en sesion.hash, es decir, si ambos hashes coinciden. Los hashes son funciones matemáticas que se utilizan para representar un valor de manera única, generalmente de un texto o conjunto de datos, y se emplean aquí para asegurar la autenticidad de una "palabra secreta" o información sensible. Si la condición no se cumple (es decir, si los dos valores de hash no son iguales), se ejecuta el mensaje de error "Palabra secreta incorrecta". Este mensaje se proporciona para que quien ejecute el contrato sepa que la verificación falló debido a que la "palabra secreta" no es correcta, indicando que no se pudo realizar la operación o transacción que se intentaba. En resumen, esta línea asegura que la verificación del hash sea exitosa antes de proceder con la lógica del contrato, y si no lo es, detiene la ejecución y muestra un mensaje de error.

          // Effects: Actualizar el estado
          haReclamado[_sessionId][msg.sender] = true; // haReclamado: Este es el nombre de una variable en el contrato. Es probable que sea un mapeo (o un diccionario) que almacena un valor booleano (true o false) indicando si un reclamo ha sido realizado o no. Esta variable tiene dos claves o índices: _sessionId: Este es un parámetro que se pasa a la función que contiene esta línea de código. Probablemente se refiere a un identificador único de una "sesión" o "evento". En términos simples, es una especie de "ID" que se asocia a un evento o acción en el contrato inteligente. Esta clave ayuda a identificar la sesión específica a la que se refiere el reclamo. msg.sender: En Solidity, msg.sender es una variable global que contiene la dirección de la cuenta (ya sea una cuenta de usuario o un contrato) que está llamando a la función que contiene esta línea de código. Es quien está ejecutando la transacción o acción. En este caso, se usa para identificar a la persona o entidad que está realizando el reclamo.= true: Esta parte de la instrucción establece el valor del mapeo en true. Es decir, se está marcando que la persona (en este caso representada por msg.sender) ha reclamado algo dentro de la sesión identificada por _sessionId. Al establecerlo en true, el contrato sabe que ya ha sido reclamado y no se podrá reclamar nuevamente, a menos que se cambie esta lógica en alguna otra parte del contrato.


          // Interactions: Realizar interacciones externas o emitir tokens
          uint256 cantidad = 10 * (10 ** decimals()); //  La línea uint256 cantidad = 10 * (10 ** decimals()); crea una variable cantidad y le asigna un valor que es 10 multiplicado por 10 elevado al número de decimales del token. Esto se usa comúnmente para definir cantidades de tokens que tienen una gran precisión decimal, asegurando que las operaciones con tokens sean consistentes con el número de decimales definidos para el contrato.
          _mint(msg.sender, cantidad); // La línea de código _mint(msg.sender, cantidad); emite (crea) cantidad de tokens y los asigna a la dirección que ejecuta la transacción (msg.sender). Esto suele ser utilizado para otorgar tokens a un usuario después de que realice alguna acción o cumpla con ciertos requisitos (como una compra, una recompensa o un reclamo).

          emit TokenReclamado(msg.sender, cantidad, _sessionId); // La línea emit TokenReclamado(msg.sender, cantidad, _sessionId); emite un evento TokenReclamado en la blockchain, proporcionando información sobre la dirección que reclamó tokens (msg.sender), la cantidad de tokens que se reclamaron (cantidad), y la sesión en la que ocurrió el reclamo (_sessionId). Este evento facilita la interacción con aplicaciones externas que pueden escuchar y reaccionar a estos eventos de manera eficiente.
      }


}
